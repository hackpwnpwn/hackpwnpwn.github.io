
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>逆向分析总结 - hackpwn</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="hackpwn,"> 
    <meta name="description" content="基本数据类型整数类型
C++提供的整数数据类型有三种：int，long，short。在Visual C++ 6.0(Visual Studio 2013同样)中，int类型和long类型在内存中都是,"> 
    <meta name="author" content="dh、Catsay"> 
    <link rel="alternative" href="atom.xml" title="hackpwn" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>

<body class="loading">
    <span id="config-title" style="display:none">hackpwn</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" target="_blank" rel="noopener" data-url="http://hackpwn.xyz"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">逆向分析总结</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" target="_blank" rel="noopener" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;" target="_blank" rel="noopener"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">逆向分析总结</h1>
        <div class="stuff">
            <span>十二月 08, 2019</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/" rel="tag">逆向分析</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><ul>
<li><p>C++提供的整数数据类型有三种：<code>int</code>，<code>long</code>，<code>short</code>。在Visual C++ 6.0(Visual Studio 2013同样)中，<code>int</code>类型和<code>long</code>类型在内存中都是占四个字节，<code>short</code>类型在内存中占两个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"int size of is:%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"long size of is:%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"short size of is:%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20191208195745647.png" alt="image-20191208195745647"></p>
<p>​        由于二进制数字不方便显示和阅读，因此内存中的数据都是采用十六进制的方式进行显示。一个字节由两个十六进制的数组成。在进制转换的过程中，一个十六进制数字可以用4个二进制数字表示，每个二进制数表示<code>1</code>位，因此一个字节在内存中占的是<code>8</code>位。</p>
<p>​        在C++中，证书类型又可以分为有符号型和无符号型两种。有符号的整数可以用来表示负数与正数，而无符号的整数则只能表示正数。</p>
</li>
</ul>
<ul>
<li>无符号整数</li>
</ul>
<p>​        在内存当中，无符号整数的所有位都用来表示数值。以无符号整数数据<code>unsigned int</code>为例，此类型的变量在内存中占用4个字节，由8个十六进制数组成，取值范围是<code>0x00000000~0xFFFFFFFF</code>，如果转换为十进制的数字，则表示范围为<code>0~4294967295</code></p>
<p>  ​        当无符号整数不足32位的时候，用<code>0</code>来填充剩余高位，直到占满4个字节内存空间为止。例如，数字<code>5</code>对应的二进制数字为<code>101</code>，只占了3位，按照4字节大小保存，剩余29个高位将用0填充，结果就是<code>00000000000000000000000000000101</code>；转换成十六进制数<code>0x00000005</code>之后，在内存中以小端排序的方式存放，小端排序就是以字节为单位，按照数据类型长度，低数据位排放在内存的低端，高数据排放在内存的高端，如<code>0x12345678</code>将会存储为<code>78 56 34 12</code>。相对于的，还有一个是大端排序，低数据放在高端，高数据放在低端。如<code>0x12345678</code>将会被存储为<code>12 34 56 78</code>。</p>
<p>  ​        由于这里讲到的是无符号的整数，不存在正负的问题，都是正数，所以无符号整数在内存中都是以真值的形式存放的，每一位都可以参与数据表达。无符号整数可以表示的正数范围是补码的一倍。</p>
<p>  <img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20191208201548574.png" alt="image-20191208201548574"></p>
<ul>
<li><p>有符号整数</p>
<p>​        有符号的整数中用来表示符号的是最高位——<code>符号位</code>。最高位是<code>0</code>的话就表示是正数，最高位是<code>1</code>的话就表示为负数。有符号整数在内存中同样也是占4个字节，但是由于最高位是符号位，不可以用来表示数值，因此有符号整数的取值范围要比无符号整数的取值范围少1位，即：<code>0x80000000~0x7FFFFFFF</code>，如果转换为十进制的数，则表示的取值范围是<code>-2147483648~2147483647</code>。</p>
<p>​        在有符号的整数中，正数的表示区间为：<code>0x00000000~0x7FFFFFFF</code></p>
<p>​                                        负数的表示区间为：<code>0x80000000~0xFFFFFFFF</code></p>
<p>​        负数在内存中都是以补码的方式进行存放的，补码的规则是用<code>0</code>减去这个数值的绝对值，也可以简单的表达为对这个数取反+1。例如：<code>-3</code>：可以表示为<code>0-3</code>，而<code>0xFFFFFFFD+3</code>等于<code>0</code>，所以<code>-3</code>的补码就是<code>0xFFFFFFFD</code>了，相对应的，<code>0xFFFFFFFD</code>作为一个补码，最高位是<code>1</code>，视为负数，转换回真值同样也可以用<code>0-0xFFFFFFFD</code>的方式。于是得到了<code>-3</code>，为了方便计算，人们尝尝也采用取反加一的方式来求得补码，因此对于任何四字节的数值<code>x</code>，都有<code>x+x(反)=0xFFFFFFFF</code>，于是<code>x+x(反)+1=0</code>，接着我们就可以推导出<code>0-x=x(反)+1</code></p>
<p>​        在我们讨论的<code>C/C++</code>中，有符号正数都是以补码的形式存储的，而且在几乎所有的编程语言中都是这样，因为计算机只会做加法，所以需要把减法转换为加法</p>
<p>​        假设有符号数<code>x,y</code>求<code>x-y</code>的值，我们可以推导出<code>x-y=x+(0-|y|)</code>，根据补码的规则，当y为负数的时候，<code>0-|y|</code>等价于y的补码。对于<code>y</code>的补码，我们记为<code>y（补）</code>，所以<code>x-y=x+y(补)</code></p>
</li>
</ul>
<p>  ​        例如，<code>（3-2）</code>可以转换成<code>(3+(-2))</code>，运算的过程为：3的十六进制原码<code>0x00000003</code>加上<code>-2</code>的十六进制补码<code>0xFFFFFFFE</code>，从而得到<code>0x10000001</code>。由于存储范围为4字节大小，两个数相加之后产生了进位，超出了存储范围，超过的1将被舍弃。进位被舍弃后，结果是<code>0x00000001</code>。</p>
<p>  值得一提的是，对于四字节的补码，<code>0x80000000</code>所表达的意义可以是负数0，也可以是<code>0x80000000</code>减去1.由于0的正负值是相等的，所以没有必要还要来一个负数的0，因此，也就是把这个值的意义规定为<code>0x80000000</code>减去1。这样<code>0x80000000</code>也就成为4字节负数的最小值了。这也是为什么有符号整数的取值范围中，负数区间总是比正数区间多一个最小值的原因。</p>
<p>  ​        在数据分析中，如果将内存解释为有符号的整数，我们使用十六进制数表示时的最高位，最高位小于8则为正数，大于8则为负数。如果是负数则需要转换成真值，从而得到对应的负数数值。</p>
<p>  <img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20191209093211710.png" alt="image-20191209093211710"></p>
<p>  ​        对于上图，地址<code>0x00AFFD30</code>对应的4字节为变量<code>nNum</code>的数据信息。<code>nNum</code>为一个有符号整数，在内存中的信息为<code>0xFFFFFFFF</code>，最高位为1，说明变量<code>nNum</code>为一个负数。按照转换规则，内存中存放的十六进制数为一个补码，需转换成真值再进行解释。0减去<code>0xFFFFFFFF</code>后，或者对<code>0xFFFFFFFF</code>取反加1，都可以得到真值<code>-1</code></p>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>​        在C/C++中,使用浮点方式存储实数，用两种数据类型来保存浮点数：<code>float(单精度)、double(双精度)</code>。<code>float</code>在内存中占4个字节，<code>double</code>在内存中占8个字节。由于占用的空间比较大，<code>double</code>可以描述的精度更高，这两种数据类型在内存中同样以十六进制方式进行存储，但是与整数类型有所不同。</p>
<p>​        整数类型是将十进制转换成二进制保存在内存中，以十六进制的方式去显示。浮点类型并不是将一个浮点小数直接转换成二进制数去保存，而是将浮点小数转换成的二进制码重新编码，再进行存储，C/C++的浮点数是有符号的。</p>
<p>​        在C/C++中，将浮点数强制转换为整数时，不会采用数学上的四舍五入法，而是会舍弃掉小数部分。</p>
<p>​        浮点数的操作不会用到通用寄存器，而会使用浮点处理器的浮点寄存器，专门对浮点数进行运算处理。</p>
<p><img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20191209101748181.png" alt="image-20191209101748181"></p>
<p>但是在Visual Studio 2013是可以通过的，VC6.0：这是由于在浮点数寄存器没有初始化时使用浮点操作，将无法完成转换小数的部分，我们可以在代码任意的一个地方定义一个浮点类型的变量即可对浮点寄存器进行初始化。</p>
<h3 id="浮点编码方式"><a href="#浮点编码方式" class="headerlink" title="浮点编码方式"></a>浮点编码方式</h3><p>​        浮点数编码转换采用的是IEEE规定的编码标准，<code>float</code>和<code>double</code>这两种类型数据的转换原理相同，但是由于表示的范围不一样，编码方式有些区别，IEEE规定的浮点数编码会将一个浮点数转换成二进制数，用科学计数法划分，将浮点数拆分为3部分：符号、指数、尾数。</p>
<ol>
<li><h3 id="float类型的IEEE编码"><a href="#float类型的IEEE编码" class="headerlink" title="float类型的IEEE编码"></a>float类型的IEEE编码</h3><p>​        float类型在内存中占的是4个字节（32位）。最高位用于表示符号；剩下的31位中，从左到右取8位用于表示指数，其余用于表示尾数。</p>
<p>​        在进行二进制转换前，需要对单精度浮点数进行科学计数法转换。例如，将<code>float</code>类型的<code>12.25f</code>转换为IEEE编码，需将<code>12.25f</code>转换成对应的二进制数<code>1100.01</code>整数部分为<code>1100</code>，小数部分为01，小数点向左移动，每移动一次指数加一，移动到除符号位的最高位为1处，停止移动，这里移动3次。对<code>12.25f</code>进行科学计数法转换后二进制部分为<code>1.10001</code>，指数部分为3。在IEEE编码中，由于在二进制情况下，最高位始终为1，为一个恒定的值，所以将其忽略不计，这里是一个正数，所以符号位添0。</p>
<p>​    </p>
<p><code>12.25</code>经过IEEE转换后各位的情况：</p>
<ul>
<li><p>符号位：0</p>
</li>
<li><p>指数位：十进制 3+127，转换为二进制是<code>10000010</code></p>
</li>
<li><p>尾数位：<code>1000100000000000000000000000000</code>（当不足32位时，低位补0填充）</p>
<p>由于尾数位中最高位1是恒定值，故省略不计，只要在转换回十进制的时候加1即可。为什么指数位要加127呢？由于指数可能出现负数的情况，十进制127可以表示为二进制数<code>01111111</code>。IEEE编码方式规定，当指数域小于<code>0111111</code>的时候为一个负数，反之则为正数，因此，<code>01111111</code>为0。</p>
<p>​    12.25f转换后的IEEE编码按照二进制拼接为：<code>01000001010001000000000000000000</code>，转换为十六进制为：<code>0x41440000</code>，在内存中小端排序进行排列的时候：<code>00 00 44 41</code>。</p>
<p><img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20191209175627338.png" alt="image-20191209175627338"></p>
</li>
</ul>
</li>
<li><h3 id="double类型的IEEE编码"><a href="#double类型的IEEE编码" class="headerlink" title="double类型的IEEE编码"></a>double类型的IEEE编码</h3></li>
</ol>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='https://link.hhtjim.com/163/1363948882.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
