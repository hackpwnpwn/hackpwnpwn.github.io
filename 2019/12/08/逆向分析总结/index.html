
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>逆向分析总结 - hackpwn</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="hackpwn,"> 
    <meta name="description" content="基本数据类型整数类型
C++提供的整数数据类型有三种：int，long，short。在Visual C++ 6.0(Visual Studio 2013同样)中，int类型和long类型在内存中都是,"> 
    <meta name="author" content="dh、Catsay"> 
    <link rel="alternative" href="atom.xml" title="hackpwn" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>

<body class="loading">
    <span id="config-title" style="display:none">hackpwn</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" target="_blank" rel="noopener" data-url="http://hackpwn.xyz"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">逆向分析总结</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" target="_blank" rel="noopener" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;" target="_blank" rel="noopener"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">逆向分析总结</h1>
        <div class="stuff">
            <span>十二月 08, 2019</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/" rel="tag">逆向分析</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><ul>
<li><p>C++提供的整数数据类型有三种：<code>int</code>，<code>long</code>，<code>short</code>。在Visual C++ 6.0(Visual Studio 2013同样)中，<code>int</code>类型和<code>long</code>类型在内存中都是占四个字节，<code>short</code>类型在内存中占两个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"int size of is:%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"long size of is:%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"short size of is:%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20191208195745647.png" alt="image-20191208195745647"></p>
<p>​        由于二进制数字不方便显示和阅读，因此内存中的数据都是采用十六进制的方式进行显示。一个字节由两个十六进制的数组成。在进制转换的过程中，一个十六进制数字可以用4个二进制数字表示，每个二进制数表示<code>1</code>位，因此一个字节在内存中占的是<code>8</code>位。</p>
<p>​        在C++中，证书类型又可以分为有符号型和无符号型两种。有符号的整数可以用来表示负数与正数，而无符号的整数则只能表示正数。</p>
</li>
</ul>
<ul>
<li>无符号整数</li>
</ul>
<p>​        在内存当中，无符号整数的所有位都用来表示数值。以无符号整数数据<code>unsigned int</code>为例，此类型的变量在内存中占用4个字节，由8个十六进制数组成，取值范围是<code>0x00000000~0xFFFFFFFF</code>，如果转换为十进制的数字，则表示范围为<code>0~4294967295</code></p>
<p>  ​        当无符号整数不足32位的时候，用<code>0</code>来填充剩余高位，直到占满4个字节内存空间为止。例如，数字<code>5</code>对应的二进制数字为<code>101</code>，只占了3位，按照4字节大小保存，剩余29个高位将用0填充，结果就是<code>00000000000000000000000000000101</code>；转换成十六进制数<code>0x00000005</code>之后，在内存中以小端排序的方式存放，小端排序就是以字节为单位，按照数据类型长度，低数据位排放在内存的低端，高数据排放在内存的高端，如<code>0x12345678</code>将会存储为<code>78 56 34 12</code>。相对于的，还有一个是大端排序，低数据放在高端，高数据放在低端。如<code>0x12345678</code>将会被存储为<code>12 34 56 78</code>。</p>
<p>  ​        由于这里讲到的是无符号的整数，不存在正负的问题，都是正数，所以无符号整数在内存中都是以真值的形式存放的，每一位都可以参与数据表达。无符号整数可以表示的正数范围是补码的一倍。</p>
<p>  <img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20191208201548574.png" alt="image-20191208201548574"></p>
<ul>
<li><p>有符号整数</p>
<p>​        有符号的整数中用来表示符号的是最高位——<code>符号位</code>。最高位是<code>0</code>的话就表示是正数，最高位是<code>1</code>的话就表示为负数。有符号整数在内存中同样也是占4个字节，但是由于最高位是符号位，不可以用来表示数值，因此有符号整数的取值范围要比无符号整数的取值范围少1位，即：<code>0x80000000~0x7FFFFFFF</code>，如果转换为十进制的数，则表示的取值范围是<code>-2147483648~2147483647</code>。</p>
<p>​        在有符号的整数中，正数的表示区间为：<code>0x00000000~0x7FFFFFFF</code></p>
<p>​                                        负数的表示区间为：<code>0x80000000~0xFFFFFFFF</code></p>
<p>​        负数在内存中都是以补码的方式进行存放的，补码的规则是用<code>0</code>减去这个数值的绝对值，也可以简单的表达为对这个数取反+1。例如：<code>-3</code>：可以表示为<code>0-3</code>，而<code>0xFFFFFFFD+3</code>等于<code>0</code>，所以<code>-3</code>的补码就是<code>0xFFFFFFFD</code>了，相对应的，<code>0xFFFFFFFD</code>作为一个补码，最高位是<code>1</code>，视为负数，转换回真值同样也可以用<code>0-0xFFFFFFFD</code>的方式。于是得到了<code>-3</code>，为了方便计算，人们尝尝也采用取反加一的方式来求得补码，因此对于任何四字节的数值<code>x</code>，都有<code>x+x(反)=0xFFFFFFFF</code>，于是<code>x+x(反)+1=0</code>，接着我们就可以推导出<code>0-x=x(反)+1</code></p>
<p>​        在我们讨论的<code>C/C++</code>中，有符号正数都是以补码的形式存储的，而且在几乎所有的编程语言中都是这样，因为计算机只会做加法，所以需要把减法转换为加法</p>
<p>​        假设有符号数<code>x,y</code>求<code>x-y</code>的值，我们可以推导出<code>x-y=x+(0-|y|)</code>，根据补码的规则，当y为负数的时候，<code>0-|y|</code>等价于y的补码。对于<code>y</code>的补码，我们记为<code>y（补）</code>，所以<code>x-y=x+y(补)</code></p>
</li>
</ul>
<p>  ​        例如，<code>（3-2）</code>可以转换成<code>(3+(-2))</code>，运算的过程为：3的十六进制原码<code>0x00000003</code>加上<code>-2</code>的十六进制补码<code>0xFFFFFFFE</code>，从而得到<code>0x10000001</code>。由于存储范围为4字节大小，两个数相加之后产生了进位，超出了存储范围，超过的1将被舍弃。进位被舍弃后，结果是<code>0x00000001</code>。</p>
<p>  值得一提的是，对于四字节的补码，<code>0x80000000</code>所表达的意义可以是负数0，也可以是<code>0x80000000</code>减去1.由于0的正负值是相等的，所以没有必要还要来一个负数的0，因此，也就是把这个值的意义规定为<code>0x80000000</code>减去1。这样<code>0x80000000</code>也就成为4字节负数的最小值了。这也是为什么有符号整数的取值范围中，负数区间总是比正数区间多一个最小值的原因。</p>
<p>  ​        在数据分析中，如果将内存解释为有符号的整数，我们使用十六进制数表示时的最高位，最高位小于8则为正数，大于8则为负数。如果是负数则需要转换成真值，从而得到对应的负数数值。</p>
<p>  <img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20191209093211710.png" alt="image-20191209093211710"></p>
<p>  ​        对于上图，地址<code>0x00AFFD30</code>对应的4字节为变量<code>nNum</code>的数据信息。<code>nNum</code>为一个有符号整数，在内存中的信息为<code>0xFFFFFFFF</code>，最高位为1，说明变量<code>nNum</code>为一个负数。按照转换规则，内存中存放的十六进制数为一个补码，需转换成真值再进行解释。0减去<code>0xFFFFFFFF</code>后，或者对<code>0xFFFFFFFF</code>取反加1，都可以得到真值<code>-1</code></p>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>​        在C/C++中,使用浮点方式存储实数，用两种数据类型来保存浮点数：<code>float(单精度)、double(双精度)</code>。<code>float</code>在内存中占4个字节，<code>double</code>在内存中占8个字节。由于占用的空间比较大，<code>double</code>可以描述的精度更高，这两种数据类型在内存中同样以十六进制方式进行存储，但是与整数类型有所不同。</p>
<p>​        整数类型是将十进制转换成二进制保存在内存中，以十六进制的方式去显示。浮点类型并不是将一个浮点小数直接转换成二进制数去保存，而是将浮点小数转换成的二进制码重新编码，再进行存储，C/C++的浮点数是有符号的。</p>
<p>​        在C/C++中，将浮点数强制转换为整数时，不会采用数学上的四舍五入法，而是会舍弃掉小数部分。</p>
<p>​        浮点数的操作不会用到通用寄存器，而会使用浮点处理器的浮点寄存器，专门对浮点数进行运算处理。</p>
<p><img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20191209101748181.png" alt="image-20191209101748181"></p>
<p>但是在Visual Studio 2013是可以通过的，VC6.0：这是由于在浮点数寄存器没有初始化时使用浮点操作，将无法完成转换小数的部分，我们可以在代码任意的一个地方定义一个浮点类型的变量即可对浮点寄存器进行初始化。</p>
<h3 id="浮点编码方式"><a href="#浮点编码方式" class="headerlink" title="浮点编码方式"></a>浮点编码方式</h3><p>​        浮点数编码转换采用的是IEEE规定的编码标准，<code>float</code>和<code>double</code>这两种类型数据的转换原理相同，但是由于表示的范围不一样，编码方式有些区别，IEEE规定的浮点数编码会将一个浮点数转换成二进制数，用科学计数法划分，将浮点数拆分为3部分：符号、指数、尾数。</p>
<ol>
<li><h3 id="float类型的IEEE编码"><a href="#float类型的IEEE编码" class="headerlink" title="float类型的IEEE编码"></a>float类型的IEEE编码</h3><p>​        float类型在内存中占的是4个字节（32位）。最高位用于表示符号；剩下的31位中，从左到右取8位用于表示指数，其余用于表示尾数。</p>
<p>​        在进行二进制转换前，需要对单精度浮点数进行科学计数法转换。例如，将<code>float</code>类型的<code>12.25f</code>转换为IEEE编码，需将<code>12.25f</code>转换成对应的二进制数<code>1100.01</code>整数部分为<code>1100</code>，小数部分为01，小数点向左移动，每移动一次指数加一，移动到除符号位的最高位为1处，停止移动，这里移动3次。对<code>12.25f</code>进行科学计数法转换后二进制部分为<code>1.10001</code>，指数部分为3。在IEEE编码中，由于在二进制情况下，最高位始终为1，为一个恒定的值，所以将其忽略不计，这里是一个正数，所以符号位添0。</p>
<p>​    </p>
<p><code>12.25</code>经过IEEE转换后各位的情况：</p>
<ul>
<li><p>符号位：0</p>
</li>
<li><p>指数位：十进制 3+127，转换为二进制是<code>10000010</code></p>
</li>
<li><p>尾数位：<code>1000100000000000000000000000000</code>（当不足32位时，低位补0填充）</p>
<p>由于尾数位中最高位1是恒定值，故省略不计，只要在转换回十进制的时候加1即可。为什么指数位要加127呢？由于指数可能出现负数的情况，十进制127可以表示为二进制数<code>01111111</code>。IEEE编码方式规定，当指数域小于<code>0111111</code>的时候为一个负数，反之则为正数，因此，<code>01111111</code>为0。</p>
<p>​    12.25f转换后的IEEE编码按照二进制拼接为：<code>01000001010001000000000000000000</code>，转换为十六进制为：<code>0x41440000</code>，在内存中小端排序进行排列的时候：<code>00 00 44 41</code>。</p>
<p><img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20191209175627338.png" alt="image-20191209175627338"></p>
</li>
</ul>
</li>
<li><h3 id="double类型的IEEE编码"><a href="#double类型的IEEE编码" class="headerlink" title="double类型的IEEE编码"></a>double类型的IEEE编码</h3></li>
</ol>
<h3 id="C语言函数及汇编指令"><a href="#C语言函数及汇编指令" class="headerlink" title="C语言函数及汇编指令"></a>C语言函数及汇编指令</h3><p><em>更新与2020.02.16-05:05心情复杂，上面的基础先不写了，先往下写点了</em></p>
<ol>
<li><p>什么是函数？</p>
<p>有返回值，有代码，有参数，有名字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//void 表示没有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"这是一个函数代码\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int 表示返回有符号int类型(一般情况下4字节)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"这是一个函数代码\r\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是很简单的一个函数。</p>
<p>那么到底函数是怎么实现的呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_asm mov eax,eax;<span class="comment">//这里正常是不会产生这样一个汇编语句的，但是这里写这条是方便定位分析的。</span></span><br><span class="line">	<span class="keyword">int</span> Value = Add(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译好之后拖进OD，断在程序入口处的时候选择搜索-&gt;命令序列，他是在当前模块搜索的，我们需要按下OD中上方的<code>E</code>，然后选择第一个右键跟随入口再去搜索，查找命令序列<code>mov eax,eax</code>，即可跳转到我们的具体分析位置，按下F2下断点就可以运行过去啦~</p>
<p>我们可以看到定位的下方是这样一串指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6A 03        push 3</span><br><span class="line">6A 02        push 2</span><br><span class="line">E8 97 FDFFFF call 001D11E0</span><br></pre></td></tr></table></figure>

<p>我们先来思考几个问题，我们的CPU是怎么知道我们要从哪里开始运行的呢？</p>
<p>这个时候就要提到我们的<code>EIP</code>寄存器，它是指引CPU去执行哪里的代码的寄存器</p>
<p>回过头来我们来看这些汇编代码，第一个<code>push 3</code>我们的EIP变为了指向<code>push 2</code>的地址，我们在执行<code>push 3</code>的时候，可以发现我们的寄存器窗口和堆栈窗口的数据发生了一些变化，首先是<code>ESP-4</code>，<code>EIP+2</code>,然后<code>3</code>被压入栈中而且压入的地址是<code>ESP-4</code>的位置，那么我们可以讲<code>push 3</code>转换为一下汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push 3 ==&gt;</span><br><span class="line">sub esp,4</span><br><span class="line">mov [esp],3</span><br></pre></td></tr></table></figure>

<p>当然我们也可以这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov [esp-4],3</span><br><span class="line">sub esp,4</span><br></pre></td></tr></table></figure>

<p>他们在本质上是一样的</p>
<p>我们再来看一下这个<code>call</code>指令，我们运行下去之后会发现寄存器窗口和堆栈窗口是有变化的，<code>EIP=call的参数</code>，<code>[esp-4]=call的下一条指令</code>，这个时候我们可以观察到，如果<code>call</code>的刚好是下一条指令的话，他的汇编写法就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub esp,4</span><br><span class="line">mov [esp-4],call的参数</span><br></pre></td></tr></table></figure>

<p>也就是说出现这种情况的时候，<code>call</code>指令和<code>push</code>的执行结果一样。大部分书上说<code>call</code>是在调用函数，我认为是要看具体的代码情况的(不同意的请打我)。我们再来看这样的几条语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push 1         --&gt; ESP-4 [ESP] = 1</span><br><span class="line">mov [esp],0    --&gt; [ESP] = 0</span><br><span class="line">------------------------------------</span><br><span class="line">push 0         --&gt; [ESP-4] [ESP] = 0</span><br></pre></td></tr></table></figure>

<p>我们可以看到<code>push 1;mov [esp],0</code>和<code>push 0</code>的结果是一样的，这两条指令是等同的，我们可以发现<code>[ESP] = 1</code>的行为被下面一条语句被覆盖掉了。语句虽然不等价，但是结果是相同的。很多指令都是可以拆解的，动态加密壳就是这些原理。</p>
<p>我们在执行<code>call</code>的时候按下<code>F7</code>步入是可以发现跳转到了一条<code>jmp</code>语句的，我们来看一下<code>jmp</code>的特征</p>
<p><code>mov eip,参数</code>，当然<code>mov</code>是不允许修改EIP的，我只是在这里给大家做一个简单方便理解的一个简化。</p>
<p>我们再来学习几个汇编指令</p>
<p><code>lea edi,dword ptr ss:[ebp-c0]</code>他其实就是把<code>ebp-c0</code>的值存入<code>edi</code>寄存器，相当于是脱掉了外面的<code>[]</code></p>
<p><code>rep stos dword ptr es:[EDI]</code>，<code>rep</code>其实是重复指令，我们按下F7会发现一些特征，他每次都会将<code>ecx</code>这个用于计数的寄存器-1，知道0为止结束</p>
<p><code>pop edi</code>，也就是和push对应的操作，将值返回给寄存器，名为出栈，效果：<code>参数=[ESP] ESP+4</code>，也就等同于如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov esi,[esp]</span><br><span class="line">add esp,4</span><br><span class="line">---------同时也可以这么写-----------</span><br><span class="line">add esp,4</span><br><span class="line">mov esi,[esp-4]</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   <code>ret</code>，执行后发现<code>EIP</code>和<code>ESP</code>发生了改变 ，观察可以发现是做了这样的操作：<code>EIP=[ESP]</code>，<code>esp+4</code>，其实类似与<code>pop eip</code>，但是是不存在这个操作的，同样是为了方便大家理解的，同样可以发现的是，<code>ret</code>的地址其实是最开始<code>call</code>调用时压入的地址，大家都知道函数执行完之后是要继续执行下一条语句的，这就是实现的原理。我们就可以总结<code>ret</code>等同于如下代码：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add esp,4</span><br><span class="line">jmp [esp-4]</span><br></pre></td></tr></table></figure>

<p>   这次是不能反过来的，因为jmp之后你下面的代码就执行不了了。</p>
<h3 id="易语言破解小栗子"><a href="#易语言破解小栗子" class="headerlink" title="易语言破解小栗子"></a>易语言破解小栗子</h3><p><em>更新与2020.03.31</em></p>
<ol>
<li><p>先来看一下demo代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.版本 <span class="number">2</span></span><br><span class="line">.支持库 spec</span><br><span class="line"></span><br><span class="line">.程序集 窗口程序集_启动窗口</span><br><span class="line"></span><br><span class="line">.子程序 __启动窗口_创建完毕</span><br><span class="line"></span><br><span class="line">编辑框<span class="number">1.</span>内容 ＝ 系统_取CPU序列号 ()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.子程序 _按钮<span class="number">1</span>_被单击</span><br><span class="line">.局部变量 注册码, 文本型</span><br><span class="line">.局部变量 机器码, 文本型</span><br><span class="line"></span><br><span class="line">机器码 ＝ 系统_取CPU序列号 ()</span><br><span class="line">注册码 ＝ 文本_颠倒 (机器码)</span><br><span class="line">调试输出 (注册码)</span><br><span class="line">.如果 (注册码 ＝ 编辑框<span class="number">2.</span>内容)</span><br><span class="line">    载入 (窗口<span class="number">1</span>, , 真)</span><br><span class="line">.否则</span><br><span class="line">    信息框 (“注册码错误”, <span class="number">0</span>, , )</span><br><span class="line">.如果结束</span><br></pre></td></tr></table></figure></li>
<li><p>其实就是取了CPU的序列号作为机器码，注册码为机器码的颠倒</p>
</li>
<li><p>我们静态编译后拖入OD进行分析。</p>
</li>
<li><p>使用OD加载程序后来到了入口地址，这里我们常规的都是看一下注册码错误提示：<code>注册码错误</code>然后去回溯关键函数，但是我们这里有一个技巧就是先让程序正常的跑起来<br><img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/e1.jpg" alt="image-e1"></p>
<p>按下od里面e按钮查看模块，双击第一个，来到<code>00401000</code>的地址，这里不懂得自行补充PE的知识。</p>
<p>然后在这边去智能搜索字符串，会比进入函数入口搜索的多。</p>
</li>
<li><p>然后在字符串窗口找到了关键字符串：<code>注册码错误</code>，双击进入，向上查找<code>push ebp</code>的位置</p>
<p><img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20200331135406351.png" alt="image-20200331135406351"></p>
<p>然后下断点运行，随便输入注册码后确认，函数随即断下来</p>
</li>
<li><p>然后我们开始分析这些代码，首先遇到第一个<code>call 0040110B</code>这个函数，我们回车进去看一下</p>
<p><img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20200331135528649.png" alt="image-20200331135528649"></p>
<p>看到了<code>cpuid</code>用来去CPU序列号的汇编指令，所以这个<code>call</code>就对应到我们易语言中的<code>系统_取CPU序列号</code>操作</p>
<p>然后F8单步走过，看到<code>eax</code>寄存器确实已经获取到了CPU的序列号</p>
<p><img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20200331135707095.png" alt="image-20200331135707095"></p>
<p>然后继续F8下去遇到了<code>call 0040153C</code>这个函数，同样回车进去看，好的看不懂，直接F8走过，看<code>eax</code>寄存器的结果</p>
<p><img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20200331135830911.png" alt="image-20200331135830911"></p>
<p>很明显的就是将原本取出的序列号进行的倒序，对应易语言中的<code>注册码 ＝ 文本_颠倒 (机器码)</code></p>
<p>继续向下走<code>call 00401C8B</code>中获取到了我们输入的假码，直到走到了<code>call 004012F9</code>处，我们回车进去看</p>
<p><img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20200331140032933.png" alt="image-20200331140032933"></p>
<p>这是易语言典型的文本对比的样子，然后基本确定这个函数是在对机器码和注册码进行对比，因为我们的注册码肯定是错误的，所以函数F8过去之后<code>eax</code>的值变成了<code>1</code>这时候我们如果在这里将<code>eax</code>置0，直接跑下去可以发现弹出了成功，我们称这个决定成功与否的函数叫做<code>关键call</code>，继续向下看代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0040142A  |.  83C4 08       add esp,0x8</span><br><span class="line">0040142D  |.  83F8 00       cmp eax,0x0</span><br><span class="line">00401430  |.  B8 00000000   mov eax,0x0</span><br><span class="line">00401435  |.  0f94c0        sete al</span><br><span class="line">00401438  |.  8945 F0       mov [local.4],eax</span><br><span class="line">0040143B  |.  8B5D F4       mov ebx,[local.3]</span><br><span class="line">0040143E  |.  85DB          test ebx,ebx</span><br></pre></td></tr></table></figure>

<p>这是典型的判断，就是如果判断</p>
<p><img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20200331140744685.png" alt="image-20200331140744685"></p>
<p>这里我们修改掉<code>ZF</code>位为1也是可以绕过的。</p>
<p>我们继续向下看，走到<code>cmp dword ptr ss:[ebp-0x10],0x0</code>位置是一个比较，走过之后因为是相等的，所以<code>Z</code>标志位变成了1，在下面的JE就会实现，跳转到验证码错误的位置，也就是说这个<code>JE</code>就是一个关键跳转，我们<code>NOP</code>掉这个跳转也是可以去成功登陆的。</p>
<p>那么我们下面来玩个小操作，我们的易语言代码中正确输入了注册码之后会载入一个新的窗体，我们在<code>je</code>跳转的下方看到了如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00401455    68 02000080     push 0x80000002</span><br><span class="line">0040145A    6A 00           push 0x0</span><br><span class="line">0040145C    68 01000000     push 0x1</span><br><span class="line">00401461    6A 00           push 0x0</span><br><span class="line">00401463    6A 00           push 0x0</span><br><span class="line">00401465    6A 00           push 0x0</span><br><span class="line">00401467    68 01000100     push 0x10001</span><br><span class="line">0040146C    68 1E230106     push 0x601231E</span><br><span class="line">00401471    68 1F230152     push 0x5201231F</span><br><span class="line">00401476    68 03000000     push 0x3</span><br></pre></td></tr></table></figure>

<p>这是在干嘛呢？<code>push 0x10001</code>是易语言载入窗口的特征，在下面以<code>0x520</code>开头的就是窗体的ID，这时候呢我们就可以想到，直接在易语言主窗口加载的时候替换掉窗口ID不就是可以绕过开始的验证了嘛？</p>
<p>我们首先复制:<code>push 0x5201231F</code>备用，然后重新载入窗口，在入口函数断点断下后不跑，我们<code>ctrl+b</code>搜索<code>FF 25</code>去找主窗口这时候会找到一堆的<code>JMP</code>跳转，这里就是易语言在初始化的，向上找会找到一个<code>push 0x52010001</code>这样一条语句，这里就是在加载易语言的主窗体，我们修改此处的汇编语句为<code>push 0x5201231F</code></p>
<p><img src="/2019/12/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/image-20200331141835978.png" alt="image-20200331141835978"></p>
<p>然后跑起来就发现我们已经绕过了最开始的验证窗口了</p>
</li>
</ol>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='https://link.hhtjim.com/163/1363948882.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
